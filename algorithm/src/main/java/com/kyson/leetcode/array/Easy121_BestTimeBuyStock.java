package com.kyson.leetcode.array;

/**
 * LeetCode 121: 买卖股票的最佳时机
 * 1. 题目分析
 * 题目要求：给定一个数组，数组中第i个元素是股票在第i天的价格。你只能选择某一天买入股票，选择在未来的某一天卖出股票，求能获得的最大利润。
 * 简单理解：就像你去菜市场买菜，想要以最低价买入，最高价卖出，获得最大利润。但有个限制：必须先买后卖（不能做空）。
 * 输入输出关系：
 * <p>
 * 输入：股票每天的价格数组 [7,1,5,3,6,4]
 * 输出：最大利润 5（第2天买入价格1，第5天卖出价格6）
 * <p>
 * 生活化比喻：你在菜市场转悠，一边记住今天见过的最便宜的苹果价格，一边看到新的价格就想"如果我之前以最低价买了苹果，现在卖出能赚多少？"
 */
public class Easy121_BestTimeBuyStock {

    /**
     * 动态规划解法：状态转移的思想
     * 状态定义：dp[i][0] 第i天不持有股票时的最大利润
     * dp[i][1] 第i天持有股票时的最大利润
     */
    public int maxProfit(int[] prices) {
        int n = prices.length;

        // 创建记录表：dp[天数][是否持有股票]
        int[][] dp = new int[n][2];

        // 第0天的初始状态
        dp[0][0] = 0;           // 第0天不买股票，利润为0
        dp[0][1] = -prices[0];  // 第0天买股票，利润为-股价

        // 从第1天开始，每天都要做决策
        for (int i = 1; i < n; i++) {
            // 今天不持有股票，有两种可能：
            // 1. 昨天就不持有，今天继续不持有
            // 2. 昨天持有，今天卖出
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);

            // 今天持有股票，有两种可能：
            // 1. 昨天就持有，今天继续持有
            // 2. 今天买入（因为只能买卖一次，所以成本就是今天的股价）
            dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
        }

        return dp[n-1][0];
    }

}
