package com.kyson.leetcode.array;

/**
    LeetCode 88. 合并两个有序数组
    1. 题目分析
    这道题要求我们将两个已经排序的数组合并成一个有序数组。
    用生活化的例子理解：
    想象你有两排已经按身高排好队的学生，现在要把他们合并成一排，并且保持身高顺序。你需要比较两排队伍最前面的学生，把较矮的放到新队伍里。
    输入输出关系：

    nums1[]: 第一个有序数组，但末尾有足够的空位（用0填充）
    nums2[]: 第二个有序数组
    m: nums1中实际元素个数
    n: nums2中实际元素个数
    输出: 直接在nums1中修改，不需要返回

    题目类型: 双指针/数组合并问题
    2. 思路讲解
    🤔 为什么不能从前往后合并？
    新手可能想：从两个数组的开头开始比较，把小的放到nums1前面。但这样会覆盖nums1原有的元素！
    打个比方: 你要整理两摞已排序的书，如果从第一本开始整理，会把原来的书弄乱。
    💡 最佳解法：从后往前合并
    核心思想: 既然nums1末尾有空位，我们就从后往前填充！
    就像整理书籍：

    比较两摞书最上面（最大）的那本
    把较大的放到新位置的最右边
    继续比较剩下的书

    算法步骤：

    设置三个指针：p1指向nums1实际元素末尾，p2指向nums2末尾，p指向nums1总长度末尾
    比较nums1[p1]和nums2[p2]，把较大的放到nums1[p]位置
    移动对应指针，继续比较
    直到所有元素处理完
 */
public class Easy088_MergeSortedArray {

    /**
     * 从后往前合并,因为 从前往后合并，把小的放到nums1前面。但这样会覆盖nums1原有的元素！
     * 就像整理书籍：
     *
     * 比较两摞书最上面（最大）的那本
     * 把较大的放到新位置的最右边
     * 继续比较剩下的书
     *
     * 时间复杂度：O(m + n)
     * @param nums1
     * @param m
     * @param nums2
     * @param n
     */
    public void merge (int[] nums1, int m, int[] nums2, int n) {

        int p1 = m - 1;
        int p2 = n - 1;
        int p = m + n - 1;

        // 比较两个数组当前位置的元素，取较大的放到nums1[p]
        while (p1 >= 0 && p2 >= 0) {
            if (nums1[p1] > nums2[p2]) {
                nums1[p] = nums1[p1];
                p1--;
            } else {
                nums1[p] = nums2[p2];
                p2--;
            }
            p--;
        }

        // 如果nums2还有剩余元素，复制到nums1中
        // 注意：如果nums1还有剩余，不需要处理，因为它们已经在正确位置了
        while (p2 >= 0) {
            nums1[p] = nums2[p2];
            p2--;
            p--;
        }
    }

}
